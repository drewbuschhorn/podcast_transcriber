import argparse
import collections
from glob import glob
import json
import logging
import os
from dotenv import load_dotenv
from parse import parse
import pysrt
from thefuzz import fuzz

from helper import open_file_wdirs, sanitize_file_name

def convert_ms_to_hms(milliseconds):
    seconds = int((milliseconds / 1000) % 60)
    minutes = int((milliseconds / (1000 * 60)) % 60)
    hours = int((milliseconds / (1000 * 60 * 60)) % 24)

    return "{:02d}:{:02d}:{:02d}".format(hours, minutes, seconds)

def write_line(file, queue, line):
  if is_a_repeat(queue, line):
    return

  queue.append(line)
  file.write(line + " ")

def is_a_repeat(queue, line):
  for index in range(len(queue)):
    queue_item = queue[index]
    fuzz_value = fuzz.partial_ratio(line, queue_item)
    step_threshold = (0.99**(index+1))*100
    if  fuzz_value > step_threshold:
      return True
  return False

def create_script(output_path, speakers = []):
  files = [os.path.normpath(i) for i in glob(output_path + '\\*.mp3.srt')]

  results = []
  for filename in files:
    pattern = output_path + '\\{start_ms:d}ms-{end_ms:d}ms_speaker_{speaker_id:S}.mp3.srt'
    result = parse(pattern, 
                   filename)
    speaker_name = result['speaker_id']
    for speaker in speakers:
      try:
        if result['speaker_id'] == speaker['speaker_id']:
          speaker_name = speaker['name']
          break
      except:
        speaker_name = result['speaker_id']

    results.append({
      "parses": {
        'start_ms':  result['start_ms'],
        'end_ms': result['end_ms'],
        'speaker_id': speaker_name
      },
      "filename": filename
    })

  results.sort(key=lambda x: x['parses']['start_ms'])

  # Read an SRT file
  with open_file_wdirs(output_path + '/real.txt', 'w') as out:
    line_record = collections.deque([], maxlen=10)
    result_iterator = iter(results)
    for result in result_iterator:
      file = result
      info = file['parses']

      try:
        interjection_files = list(filter(lambda x: True if x['parses']['start_ms'] > info['start_ms']+1 
                                and x['parses']['end_ms'] < info['end_ms'] else False, 
                                results))
        interjection_lines = []
        for j in interjection_files:
          results.remove(j)

          interjection_line = '\n[interjection] '
          # out.write(str(convert_ms_to_hms(j['parses']['start_ms'])) + " - ")
          interjection_line += j['parses']['speaker_id'] + ": "
          _subs = pysrt.open(j['filename'])
          for k in _subs:
            if not is_a_repeat(line_record, k.text):
              interjection_line += k.text
              interjection_lines.append({
                'start_time': j['parses']['start_ms'] + k.start.ordinal,
                'end_time': j['parses']['end_ms'],
                'origin': j,
                'raw_line': k.text,
                'line': interjection_line
              })
      except IndexError:
        pass
      except Exception as e:
        raise e

      subs = pysrt.open(file['filename'])
      show_original_speaker_after_interjection = False
      first_line = True
      for line in subs:
        if len(line.text.strip()) > 1:
          if first_line and not is_a_repeat(line_record, line.text.strip()):
            out.write("\n["+str(convert_ms_to_hms(info['start_ms'])) + "] ")
            out.write(info['speaker_id'] + ":\n")
            first_line = False

          if show_original_speaker_after_interjection:
            out.write("\n[interjection] " + info['speaker_id'] + ": ")

          write_line(out, line_record, line.text.strip())
          show_original_speaker_after_interjection = False
          for l in interjection_lines:
            if l['start_time'] >= file['parses']['start_ms'] and l['end_time'] <= file['parses']['end_ms']:
              if l['start_time'] >= file['parses']['start_ms'] + line.start.ordinal and \
                    l['end_time'] <= file['parses']['start_ms'] + line.end.ordinal:
                      interjection_lines.remove(l)
                      if not is_a_repeat(line_record, l['raw_line']) and len(l['raw_line'].strip()) > 1:
                        line_record.append(l['raw_line'])
                        out.write(l['line'])
                        show_original_speaker_after_interjection = True
      if len(subs) > 0 and len(subs[0].text.strip()) > 1:
        out.write('\n')
      #out.write(str(convert_ms_to_hms(info['end_ms'])))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
                    prog='podcast_srts_to_transcript',
                    description='Reads SRT files generated by my_transcribe.py'+
                                ' in output/[input_file_name]/*.mp3.srt into a single text file for humans.',
                    epilog='Find in output/[input_file_name]/real.txt , run podcast_transcript_gpt_fixup.py to do further clean-up.')
    parser.add_argument('--names', metavar='-n', default="[]", required = False,
                    help='Names of speakers in json array format: ' + 
                          '[{\\"name\\":\\"Drew\\",\\"speaker_id\\":\\"SPEAKER_00\\"},{\\"name\\":\\"Kristin\\",\\"speaker_id\\":\\"SPEAKER_01\\"}]' )
    parser.add_argument('--file', metavar='-f', required=True,
                    help='file name of podcast file (to find working direction in output directoy)')
    parser.add_argument('--output', metavar='-o', default='output', required = False,
                    help='output directory to work in')
    parser.add_argument('-l', '--loglevel', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                    default='INFO', help='Set the logging level')
    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel)
    load_dotenv()

    create_script(speakers = json.loads(args.names), 
                  output_path=args.output + '\\' + sanitize_file_name(args.file))